<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>ASCII Geometry Dash</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --surface-color: #2c2c2c;
            --primary-color: #eab308;
            --text-color: #e5e7eb;
            --text-muted-color: #9ca3af;
            --border-color: #4b5563;
        }
        html, body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            text-align: center;
            -webkit-user-select: none; user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        #game-wrapper {
            border: 2px solid var(--border-color);
            padding: 10px;
            background-color: var(--surface-color);
            border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05);
            width: 95vw;
            max-width: 1200px;
        }
        #game-container {
            border: 2px solid #000;
            padding: 2px;
            background-color: #000;
            overflow: hidden;
        }
        #game-screen {
            font-family: 'Courier New', Courier, monospace;
            font-size: calc(0.35vw + 3px);
            line-height: 0.85;
            letter-spacing: -0.2px;
            white-space: pre;
            color: #ccc;
        }
        #ui-container {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            box-sizing: border-box;
        }
        #menu-toggle {
            font-size: 24px;
            background: none;
            border: none;
            color: var(--text-muted-color);
            cursor: pointer;
            padding: 5px;
        }
        #button-container { display: flex; gap: 10px; }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: var(--surface-color);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            border-radius: 6px;
            transition: background-color 0.2s, color 0.2s;
        }
        button:hover {
            background-color: var(--primary-color);
            color: #000;
        }
        #info { margin-top: 10px; color: var(--text-muted-color); min-height: 20px; }

        #menu-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.6);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            z-index: 999;
        }
        #level-menu {
            position: fixed;
            top: 0; left: -320px;
            width: 300px; height: 100%;
            background-color: var(--surface-color);
            box-shadow: 5px 0 15px rgba(0,0,0,0.2);
            padding: 20px;
            box-sizing: border-box;
            transition: left 0.3s;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }
        body.menu-active #menu-overlay { opacity: 1; visibility: visible; }
        body.menu-active #level-menu { left: 0; }
        
        #level-menu h2 {
            margin-top: 0;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
            color: var(--text-color);
        }
        #level-menu-header { display: flex; justify-content: space-between; align-items: center; }
        #menu-close { font-size: 24px; cursor: pointer; background:none; border:none; color: var(--text-muted-color); }

        .level-list {
            list-style: none;
            padding: 0;
            margin: 10px 0;
            overflow-y: auto;
            flex-grow: 1;
        }
        .level-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 10px;
            background-color: #333;
            margin-bottom: 5px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .level-item:hover { background-color: var(--border-color); }
        .level-item-actions button {
            background: none;
            border: none;
            color: var(--text-muted-color);
            padding: 2px 5px;
            font-size: 14px;
            cursor: pointer;
            opacity: 0.7;
        }
        .level-item-actions button:hover { opacity: 1; color: var(--primary-color); }

        #import-button { width: 100%; margin-top: auto; }
        #file-input { display: none; }
        
        .player { color: #FFFF00; font-weight: bold; } .solid { color: #FFFFFF; } .enemy { color: #FF3333; }
        .portal-ship { color: #ff80ed; } .portal-ball { color: #ff9900; } .portal-wave { color: #38bdf8; }
        .portal-robot { color: #aaaaaa; } .portal-cube { color: #4ade80; }
        .portal-grav-up { color: #f97316; } .portal-grav-down { color: #3b82f6; }
        .orb-yellow { color: #facc15; } .pad-yellow { color: #facc15; }
        .orb-pink { color: #ec4899; } .pad-pink { color: #ec4899; }
        .orb-red { color: #dc2626; } .pad-red { color: #dc2626; }
        .orb-blue { color: #38bdf8; } .pad-blue { color: #38bdf8; }
        .win { color: #84cc16; }
    </style>
</head>
<body>
    <div id="game-wrapper">
        <div id="ui-container">
            <button id="menu-toggle">â˜°</button>
            <div id="button-container">
                <button id="start-button">Start</button>
                <button id="reset-button" style="display: none;">Reset</button>
            </div>
        </div>
        <div id="game-container">
            <pre id="game-screen"></pre>
        </div>
        <div id="info">Tap Start to Play!</div>
    </div>

    <div id="menu-overlay"></div>
    <div id="level-menu">
        <div id="level-menu-header">
            <h2>Levels</h2>
            <button id="menu-close">âœ•</button>
        </div>
        
        <h3>Built-in Levels</h3>
        <ul id="built-in-list" class="level-list"></ul>
        
        <h3>Custom Levels</h3>
        <ul id="custom-level-list" class="level-list"></ul>
        
        <input type="file" id="file-input" accept=".txt">
        <button id="import-button">Import Level (.txt)</button>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {

    const gameScreen = document.getElementById('game-screen');
    const startButton = document.getElementById('start-button');
    const resetButton = document.getElementById('reset-button');
    const infoDisplay = document.getElementById('info');
    const menuToggle = document.getElementById('menu-toggle');
    const menuClose = document.getElementById('menu-close');
    const menuOverlay = document.getElementById('menu-overlay');
    const builtInList = document.getElementById('built-in-list');
    const customLevelList = document.getElementById('custom-level-list');
    const importButton = document.getElementById('import-button');
    const fileInput = document.getElementById('file-input');

    const BUILT_IN_LEVELS = [
        {
            name: "Level 1",
            data: `
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
0000000000000000000000000000000000000000000000000000000000BB000BB0000000000BBBBBBBBBBBBBBBBBBBBBBBBBBssssssssssssssssssssF
0000000000000000000000000000000000000000000000000000000000BBBBBBB0000000000BBBBBBBBBBBBBBBBBBBBBBBBBB00000000000000000000F
0000000000000000000000000000000000000000000000000000000000BBBBBBB0000000000BBBBBBBBBBBBBBBBBBBBBBBBBB00000000000000000000F
000000000000000000000000000000000000000000000000000000000000000000000000000BBBBBBBBBBBBBBBBBBBBBBBBBB00000000000000000000F
0000000000000000000000000000000000000000000000B0000000000000000000000000000BBBBBBBBBBBBBBBBBBBBBBBBBB00000000000000000000F
0000000000000000000000000000000000000000000000s0000000000000000000000000(gr)000000s00000sBBBBBBBBBBBB00000000000000000000F
000000000000000000000000000000000000000000000000000y00000000000000000000(gr)0000000000000BBBB0000000s00000000000000000000F
000000000000000000000000000000000000000000000000S000000BBBBBBBBBB0000000(gr)000000000000000000000(gn)000000000000000000B0F
00000000000000000000000000000000000000S0BBBBBBBBB000000000BBBBBBB0000BBBBBBB00000000000000000SS00(gn)000000S0000000BB00B0F
00000000000000000000SS0000BBBBBBBBBBB0B0000000000000000000BB000BB0000BBBBBBB0000000000000000SBBS0(gn)000000BBBBBSSSBBSSB0F
P000000000000SBBBBBBBBBBBBBBBBBBBBBBBSSSSSSSSSSSSSSSSSSSSSBB000BBSSSSBB000BBSSSSSSSSSSSSSSSSBBBBBBBBBBBBBBBBBBBBBBBBBBBB0F
GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG
`
        },
        {
            name: "Level 2",
            data: `
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss000000sssssssssssF
0000000000000000000000000000000000000000000000000000000000000000000(gn)000000000(gn)0000000000000000F
00000000000000000000000BBBBBBBBBBBBBBBBBBBBBBBBBBBB0000000000000000(gn)0000000000(gn)000000000000000F
000000000000000000000000000000ss000000ss000000000000000000000000000(gn)00000000000000000000000000000F
0000000000000000000000000000000000000000000000000BBBBBBB000000000000000000000000(bg)0000000000000000F
0000000000000000000000000000000000SS00000000S0000B00000BBBBBB000000000S0000000(Pj)000000000000000000F
00000000000000000000000000000BBBBBBBBBBBBBBBB0000B00000B0000BBBBBBBBBBBBBBBBBBBBBB00000000000000R000F
03000000000000000000000000000BBBBBBBBBBBBBBBB0000B00000B0000B00000000000000000000B00000BBBBBBBBBB000F
03000000000000000000000000000BB000000000000BB0000B00000B0000B00000000000000000000B00000BBBBBBBBBB000F
P3000000000000000000000000000BB000000000000BB0000B00000B0000B00000000000000000000B00000000BB000BB000F
BBBBBBBBBBBB00000000000000000BB000000000000BB0000B00000B0000B00000000000000000000B00000000BB000BB000F
BBBBBBBBBBBB00BBBBBBBB0000000BB000000000000BB0000B00000B0000B00000000000000000000B00000000BB000BB000F
BB00000000BB00BBBBBBBB0000000BB000000000000BB0000B00000B0000B00000000000000000000B00000000BB000BB000F
BB00000000BBSSBB0000BBSSSSSSSBB000000000000BBSSSSB00000B0000B00000000000000000000BSSSSSSSSBB000BB000F
GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG
`
        }
    ];
    let customLevels = [];

    const SCREEN_WIDTH_CHARS = 240, SCREEN_HEIGHT_CHARS = 80;
    const GAME_UNITS_PER_BLOCK = 30;
    const CHARS_PER_BLOCK_V = 3, CHARS_PER_BLOCK_H = 6;

    const PHYSICS_TICK_RATE = 60;
    const PHYSICS_DELTA_TIME = 1 / PHYSICS_TICK_RATE;
    const PHYSICS = {
        cube: {
            gravity: 2955 / 10.0, hSpeed: 258.0 / 4.58,
            jumpVelocity: -724.5 / 10.0,
            jumpVelocityPink: -724.5 * 0.7 / 10.0,
            jumpVelocityRed: -724.5 * 1.2 / 10.0,
        },
        ship: {
            gravity: 2955 / 15.0, thrust: -4432.5 / 15.0,
            hSpeed: 258.0 / 12.0,
            maxUpwardVel: -25.0, maxDownwardVel: 25.0,
        },
        ball: {
            gravity: 2955 / 10.0, hSpeed: 258.0 / 4.58,
        },
        wave: {
            hSpeed: 258.0 / 4.58,
        },
        robot: {
            gravity: 2955 / 10.0, hSpeed: 258.0 / 4.58,
            jumpVelocity: -724.5 / 10.0,
        }
    };

    const SHAPES = {
        player: { cube:  ['â•­â–ˆâ–ˆâ–ˆâ•®','â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ','â•°â–ˆâ–ˆâ–ˆâ•¯'], ship:  ['  â•±','-â–ˆâ–ˆâ•®','`â–ˆâ–ˆâ•¯'], ball:  ['â•­â”€Oâ”€â•®','â•°â”€Oâ”€â•¯'], wave:  ['â•±','â”€','â•²'], robot: ['[O.O]','-â–“-',' / \\ '], dead: ['X X',' X ','X X'] },
        block: { solid: ['â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ','â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ','â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ'] },
        spike_up: ['  ^  ',' / \\ ','/â–’â–ˆâ–’\\'], spike_down: ['\\â–’â–ˆâ–’/',' \\ / ','  v  '],
        orb_yellow: ['â•­â”€â”€â”€â•®','( O )','â•°â”€â”€â”€â•¯'], orb_pink: ['â•­â”€â”€â”€â•®','( p )','â•°â”€â”€â”€â•¯'], orb_red: ['â•­â”€â”€â”€â•®','( R )','â•°â”€â”€â”€â•¯'], orb_blue: ['â•­â”€â”€â”€â•®','( B )','â•°â”€â”€â”€â•¯'],
        pad_yellow: ['â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ','======'], pad_pink: ['â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ','pppppp'], pad_red: ['â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ','RRRRRR'], pad_blue: ['â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ','BBBBBB'],
        portal: ['â•±â•²','||','â•²â•±'], win: ['\\*W*/','* I *','/*N*\\'],
    };
    
    const TILE_MAP = {
        'P': { type: 'player_start' }, 'F': { type: 'win' },
        'B': { type: 'block_solid' }, 'G': { type: 'block_solid' }, 'C': { type: 'block_solid' },
        'S': { type: 'spike_up' }, 's': { type: 'spike_down' },
        'y': { type: 'orb_yellow' }, 'Y': { type: 'pad_yellow' },
        'r': { type: 'orb_red' }, 'R': { type: 'pad_red' },
        '(pj)': { type: 'orb_pink' }, '(Pj)': { type: 'pad_pink' },
        '(bg)': { type: 'orb_blue' }, '(Bg)': { type: 'pad_blue' },
        '1': { type: 'portal_cube' }, '2': { type: 'portal_ship' }, '3': { type: 'portal_ball' }, '4': { type: 'portal_wave' },
        '(gn)': { type: 'portal_grav_down' }, '(gr)': { type: 'portal_grav_up' },
    };

    let player, camera, gameRunning, inputState = { holding: false, pressedThisFrame: false }, timeAccumulator, screenBuffer, isGameOver, levelObjects, domGrid, lastScreenBuffer, activeLevel = {type: 'built-in', index: 0};
    
    function initializeDomGrid() {
        const fragment = document.createDocumentFragment();
        domGrid = [];
        for (let y = 0; y < SCREEN_HEIGHT_CHARS; y++) {
            const row = [];
            for (let x = 0; x < SCREEN_WIDTH_CHARS; x++) {
                const span = document.createElement('span');
                span.textContent = ' ';
                fragment.appendChild(span);
                row.push(span);
            }
            fragment.appendChild(document.createTextNode('\n'));
            domGrid.push(row);
        }
        gameScreen.innerHTML = '';
        gameScreen.appendChild(fragment);
    }

    function parseLevel(text) {
        const lines = text.trim().split('\n'); const parsedObjects = []; let playerStart = { x: 5, y: 5 };
        for (let y = 0; y < lines.length; y++) { const line = lines[y];
            for (let x = 0; x < line.length; x++) {
                const char = line[x]; if (char === '0' || char === ' ') continue; let token = char; let isUpsideDown = false;
                if (char === '(') { const endIndex = line.indexOf(')', x); if (endIndex !== -1) { token = line.substring(x, endIndex + 1); x = endIndex; } }
                if (line[x + 1] === '.' && line[x + 2] === 'U') { isUpsideDown = true; x += 2; }
                let definition = TILE_MAP[token]; if (!definition) continue;
                if (definition.type === 'player_start') { playerStart = { x: x, y: y }; continue; }
                if (isUpsideDown) { if (definition.type === 'spike_up') definition = { type: 'spike_down' }; }
                parsedObjects.push({ type: definition.type, x: x, y: y });
            }
        }
        return { objects: parsedObjects, playerStart };
    }

    function resetGame(levelType = activeLevel.type, levelIndex = activeLevel.index) {
        activeLevel = { type: levelType, index: levelIndex };
        const levelSource = levelType === 'custom' ? customLevels : BUILT_IN_LEVELS;
        const level = levelSource[levelIndex];
        if (!level) { return; }

        const parsedLevel = parseLevel(level.data);
        levelObjects = [];
        for(const obj of parsedLevel.objects) {
            levelObjects.push({ ...obj, px: obj.x * CHARS_PER_BLOCK_H, py: obj.y * CHARS_PER_BLOCK_V, pw: (obj.width || 1) * CHARS_PER_BLOCK_H, ph: (obj.height || 1) * CHARS_PER_BLOCK_V });
        }
        player = {
            x: parsedLevel.playerStart.x * CHARS_PER_BLOCK_H, y: parsedLevel.playerStart.y * CHARS_PER_BLOCK_V,
            w: 0, h: 0, vx: PHYSICS.cube.hSpeed, vy: 0,
            gamemode: 'cube', gravity: PHYSICS.cube.gravity, onGround: false, angle: 0,
            isDead: false,
        };
        camera = { x: 0 }; gameRunning = false; isGameOver = false; timeAccumulator = 0;
        inputState = { holding: false, pressedThisFrame: false };
        startButton.style.display = 'inline-block';
        resetButton.style.display = 'none';
        infoDisplay.textContent = "Tap Start to Play!";
        initScreenBuffer();
    }
    
    function startGame() {
        if (gameRunning || player.isDead || isGameOver) return;
        gameRunning = true; lastTime = performance.now();
        startButton.style.display = 'none';
        resetButton.style.display = 'inline-block';
        requestAnimationFrame(gameLoop);
    }

    function handleInputDown(e) { e.preventDefault(); if (inputState) { inputState.holding = true; inputState.pressedThisFrame = true; } }
    function handleInputUp(e) { e.preventDefault(); if (inputState) inputState.holding = false; }
    window.addEventListener('keydown', handleInputDown); window.addEventListener('keyup', handleInputUp);
    window.addEventListener('mousedown', handleInputDown); window.addEventListener('mouseup', handleInputUp);
    window.addEventListener('touchstart', handleInputDown, { passive: false }); window.addEventListener('touchend', handleInputUp, { passive: false });
    
    startButton.addEventListener('click', startGame);
    resetButton.addEventListener('click', () => { endLevel("Reset!", false); });
    
    function handleInteractions() {
        let playerBox = { x: player.x, y: player.y, w: player.w, h: player.h };
        for (const obj of levelObjects) {
            if (obj.type.startsWith('block') || obj.type.startsWith('spike')) continue;
            if (Math.abs(obj.px - player.x) > 150) continue;
            let objBox = { x: obj.px, y: obj.py, w: obj.pw, h: obj.ph };
            const type = obj.type;
            if (type.startsWith('orb')) {
                const orbHitboxScale = 1.2; const biggerWidth = objBox.w * orbHitboxScale; const biggerHeight = objBox.h * orbHitboxScale;
                objBox = { x: objBox.x - (biggerWidth - objBox.w) / 2, y: objBox.y - (biggerHeight - objBox.h) / 2, w: biggerWidth, h: biggerHeight };
            }
            const isColliding = playerBox.x < objBox.x + objBox.w && playerBox.x + playerBox.w > objBox.x && playerBox.y < objBox.y + objBox.h && playerBox.y + playerBox.h > objBox.y;
            if (isColliding) {
                if (type.startsWith('portal')) {
                     const lastGamemode = player.gamemode;
                     let newGamemode = player.gamemode;
                     switch(type) {
                        case 'portal_ship': newGamemode = 'ship'; break; case 'portal_ball': newGamemode = 'ball'; break;
                        case 'portal_wave': newGamemode = 'wave'; break; case 'portal_robot': newGamemode = 'robot'; break;
                        case 'portal_cube': newGamemode = 'cube'; break;
                        case 'portal_grav_up': player.gravity = -Math.abs(PHYSICS[player.gamemode].gravity); player.vy = 0; break;
                        case 'portal_grav_down': player.gravity = Math.abs(PHYSICS[player.gamemode].gravity); player.vy = 0; break;
                    }
                    if (lastGamemode !== newGamemode) {
                        player.gamemode = newGamemode;
                        const newModePhysics = PHYSICS[player.gamemode];
                        player.gravity = newModePhysics.gravity; player.vx = newModePhysics.hSpeed;
                        if(player.gamemode === 'wave') player.vy = -player.vx;
                    }
                }
                else if (type.startsWith('pad_') && player.vy * Math.sign(player.gravity) >= 0) {
                    if (type === 'pad_blue') { player.gravity *= -1; player.vy *= -1; }
                    else {
                        let jumpV = PHYSICS.cube.jumpVelocity;
                        if (type === 'pad_pink') jumpV = PHYSICS.cube.jumpVelocityPink;
                        if (type === 'pad_red') jumpV = PHYSICS.cube.jumpVelocityRed;
                        player.vy = jumpV * Math.sign(player.gravity);
                    }
                }
                else if (type.startsWith('orb_') && inputState.pressedThisFrame) {
                    if (type === 'orb_blue') { player.gravity *= -1; player.vy *= -1; }
                    else {
                        let jumpV = PHYSICS.cube.jumpVelocity;
                        if (type === 'orb_pink') jumpV = PHYSICS.cube.jumpVelocityPink;
                        if (type === 'orb_red') jumpV = PHYSICS.cube.jumpVelocityRed;
                        player.vy = jumpV * Math.sign(player.gravity);
                    }
                    inputState.pressedThisFrame = false;
                }
                else if (type === 'win') return endLevel("You Win!", true);
            }
        }
    }

    function updatePhysics() {
        if (!gameRunning) return;
        player.w = SHAPES.player[player.gamemode][0]?.length || 1;
        player.h = SHAPES.player[player.gamemode].length || 1;
        const modePhysics = PHYSICS[player.gamemode]; const gravSign = Math.sign(player.gravity);
        switch(player.gamemode) {
            case 'cube': if (player.onGround && inputState.pressedThisFrame) player.vy = modePhysics.jumpVelocity * gravSign; break;
            case 'ship':
                let netAcceleration = player.gravity;
                if (inputState.holding) { netAcceleration += modePhysics.thrust; }
                player.vy += netAcceleration * PHYSICS_DELTA_TIME;
                if(gravSign > 0) { player.vy = Math.max(modePhysics.maxUpwardVel, Math.min(modePhysics.maxDownwardVel, player.vy)); }
                else { player.vy = Math.max(-modePhysics.maxDownwardVel, Math.min(-modePhysics.maxUpwardVel, player.vy)); }
                break;
            case 'ball': if(player.onGround && inputState.pressedThisFrame){ player.gravity *= -1; } break;
            case 'wave': if (inputState.pressedThisFrame) player.vy *= -1; break;
            case 'robot': if (player.onGround && inputState.pressedThisFrame) player.vy = modePhysics.jumpVelocity * gravSign; break;
        }
        player.x += player.vx * PHYSICS_DELTA_TIME;
        for (const obj of levelObjects) {
            if (!obj.type.startsWith('block') && !obj.type.startsWith('spike')) continue;
            if (Math.abs(obj.px - player.x) > 150) continue;
            const playerBox = { x: player.x, y: player.y, w: player.w, h: player.h };
            const objBox = { x: obj.px, y: obj.py, w: obj.pw, h: obj.ph };
            if (playerBox.x < objBox.x + objBox.w && playerBox.x + playerBox.w > objBox.x && playerBox.y < objBox.y + objBox.h && playerBox.y + playerBox.h > objBox.y) {
                if (obj.type.startsWith('block') && (player.gamemode === 'cube' || player.gamemode === 'ship')) return endLevel("Ouch!", false);
                if (player.vx > 0) player.x = objBox.x - player.w; else if(player.vx < 0) player.x = objBox.x + objBox.w;
            }
        }
        if (player.gamemode !== 'wave') player.vy += player.gravity * PHYSICS_DELTA_TIME;
        player.y += player.vy * PHYSICS_DELTA_TIME;
        player.onGround = false;
        for (const obj of levelObjects) {
            if (!obj.type.startsWith('block') && !obj.type.startsWith('spike')) continue;
            if (Math.abs(obj.px - player.x) > 150) continue;
            const playerBox = { x: player.x, y: player.y, w: player.w, h: player.h };
            const objBox = { x: obj.px, y: obj.py, w: obj.pw, h: obj.ph };
            if (playerBox.x < objBox.x + objBox.w && playerBox.x + playerBox.w > objBox.x && playerBox.y < objBox.y + objBox.h && playerBox.y + playerBox.h > objBox.y) {
                const type = obj.type;
                if (type.startsWith('spike')) {
                    const isLethalContact = (type === 'spike_up' && playerBox.y + playerBox.h > objBox.y + objBox.ph * 0.66) || (type === 'spike_down' && playerBox.y < objBox.y + objBox.ph * 0.33);
                    if (isLethalContact) return endLevel("Ouch!", false);
                }
                if (type.startsWith('block')) {
                    const isFalling = player.vy * gravSign > 0;
                    const isRising = player.vy * gravSign < 0;
                    if (isFalling) {
                        if (gravSign > 0) player.y = obj.py - player.h; else player.y = obj.py + obj.ph;
                        player.vy = 0; player.onGround = true;
                    } else if (isRising) {
                        if (player.gamemode === 'cube') return endLevel("Ouch!", false);
                        if (gravSign > 0) player.y = obj.py + obj.ph; else player.y = obj.py - player.h;
                        player.vy = 0;
                    }
                }
            }
        }
        handleInteractions();
    }
    function rotateShape(shape, angle) { return shape; }
    function initScreenBuffer() {
        screenBuffer = Array.from({ length: SCREEN_HEIGHT_CHARS }, () => Array.from({ length: SCREEN_WIDTH_CHARS }, () => ({ char: ' ', className: '' })));
        lastScreenBuffer = Array.from({ length: SCREEN_HEIGHT_CHARS }, () => Array.from({ length: SCREEN_WIDTH_CHARS }, () => ({ char: '?', className: '?' })));
    }
    function drawShape(x, y, shape, className) {
        for (let r = 0; r < shape.length; r++) { for (let c = 0; c < shape[r].length; c++) {
            const drawX = Math.floor(x + c), drawY = Math.floor(y + r);
            if (drawY >= 0 && drawY < SCREEN_HEIGHT_CHARS && drawX >= 0 && drawX < SCREEN_WIDTH_CHARS && shape[r][c] !== ' ') {
                screenBuffer[drawY][drawX] = { char: shape[r][c], className }; } } }
    }
    function render() {
        for (let y = 0; y < SCREEN_HEIGHT_CHARS; y++) { for (let x = 0; x < SCREEN_WIDTH_CHARS; x++) {
            screenBuffer[y][x] = { char: ' ', className: '' };
        }}
        camera.x = player.x - 40;
        for(const obj of levelObjects) {
             if (obj.px + obj.pw < camera.x || obj.px > camera.x + SCREEN_WIDTH_CHARS) continue;
             const screenX = obj.px - camera.x, screenY = obj.py;
             let shape; let className = obj.type.replace(/_/g, '-');
             if(obj.type === 'block_solid') { shape = SHAPES.block.solid; }
             else if(obj.type === 'spike_up') { shape = SHAPES.spike_up; }
             else if(obj.type === 'spike_down') { shape = SHAPES.spike_down; }
             else if (obj.type.startsWith('pad_')) {
                const color = obj.type.split('_')[1];
                shape = SHAPES[`pad_${color}`] || SHAPES.pad_yellow;
             }
             else if (obj.type.startsWith('orb_')) {
                const color = obj.type.split('_')[1];
                shape = SHAPES[`orb_${color}`] || SHAPES.orb_yellow;
             }
             else if(obj.type.startsWith('portal')) { shape = SHAPES.portal; }
             else if(obj.type === 'win') { shape = SHAPES.win; }
             if(shape) drawShape(screenX, screenY, shape, className);
        }
        let playerShape;
        if (player.isDead) { playerShape = SHAPES.player.dead; }
        else { playerShape = SHAPES.player[player.gamemode]; if (player.angle !== 0) playerShape = rotateShape(playerShape, player.angle); }
        player.w = playerShape[0]?.length || 1; player.h = playerShape.length || 1;
        drawShape(player.x - camera.x, player.y, playerShape, 'player');
        
        for (let y = 0; y < SCREEN_HEIGHT_CHARS; y++) {
            for (let x = 0; x < SCREEN_WIDTH_CHARS; x++) {
                const current = screenBuffer[y][x];
                const last = lastScreenBuffer[y][x];
                if (current.char !== last.char || current.className !== last.className) {
                    domGrid[y][x].textContent = current.char;
                    domGrid[y][x].className = current.className;
                }
            }
        }
        lastScreenBuffer = screenBuffer.map(row => row.map(cell => ({...cell})));
    }
    function endLevel(message, isWin) {
        if (isGameOver || player.isDead) return;
        gameRunning = false;
        
        if (isWin) {
            isGameOver = true;
            infoDisplay.textContent = message;
            infoDisplay.style.color = '#84cc16';
        } else {
            player.isDead = true;
            infoDisplay.textContent = message;
            infoDisplay.style.color = '#FF3333';
            render();
            setTimeout(() => {
                resetGame(activeLevel.type, activeLevel.index);
                render();
            }, 750);
        }
    }
    let lastTime = 0;
    function gameLoop(timestamp) {
        if (!gameRunning) return; requestAnimationFrame(gameLoop);
        const elapsed = (timestamp - lastTime) / 1000; lastTime = timestamp;
        timeAccumulator += Math.min(elapsed, 0.1);
        while (timeAccumulator >= PHYSICS_DELTA_TIME) {
            updatePhysics(); if(!gameRunning) break;
            timeAccumulator -= PHYSICS_DELTA_TIME; inputState.pressedThisFrame = false;
        }
        render();
        if (!isGameOver && !player.isDead) {
            const gravityDir = player.gravity > 0 ? 'â†“' : 'â†‘';
            infoDisplay.textContent = `Mode: ${player.gamemode} | Gravity: ${gravityDir}`;
            infoDisplay.style.color = '#aaa';
        }
    }

    function populateLevelMenu() {
        builtInList.innerHTML = '';
        customLevelList.innerHTML = '';
        BUILT_IN_LEVELS.forEach((level, index) => {
            const li = document.createElement('li');
            li.className = 'level-item';
            li.textContent = level.name;
            li.dataset.type = 'built-in';
            li.dataset.index = index;
            li.addEventListener('click', () => {
                resetGame('built-in', index);
                startGame();
                closeMenu();
            });
            builtInList.appendChild(li);
        });
        customLevels.forEach((level, index) => {
            const li = document.createElement('li');
            li.className = 'level-item';
            const nameSpan = document.createElement('span');
            nameSpan.textContent = level.name;
            li.appendChild(nameSpan);
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'level-item-actions';
            const exportBtn = document.createElement('button');
            exportBtn.textContent = 'ðŸ“¥';
            exportBtn.title = 'Export Level';
            exportBtn.addEventListener('click', (e) => { e.stopPropagation(); exportLevel(index); });
            actionsDiv.appendChild(exportBtn);
            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'ðŸ—‘ï¸';
            deleteBtn.title = 'Delete Level';
            deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); deleteLevel(index); });
            actionsDiv.appendChild(deleteBtn);
            li.appendChild(actionsDiv);
            li.dataset.type = 'custom';
            li.dataset.index = index;
            li.addEventListener('click', () => {
                resetGame('custom', index);
                startGame();
                closeMenu();
            });
            customLevelList.appendChild(li);
        });
    }

    function openMenu() { document.body.classList.add('menu-active'); }
    function closeMenu() { document.body.classList.remove('menu-active'); }

    menuToggle.addEventListener('click', openMenu);
    menuClose.addEventListener('click', closeMenu);
    menuOverlay.addEventListener('click', closeMenu);
    window.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeMenu(); });
    
    importButton.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            const levelData = e.target.result;
            const levelName = prompt("Enter a name for the new level:", file.name.replace('.txt', '')) || "Custom Level";
            customLevels.push({ name: levelName, data: levelData });
            saveCustomLevels();
            populateLevelMenu();
        };
        reader.readAsText(file);
        fileInput.value = '';
    });

    function saveCustomLevels() {
        localStorage.setItem('asciiGDCustomLevels', JSON.stringify(customLevels));
    }
    function loadCustomLevels() {
        const saved = localStorage.getItem('asciiGDCustomLevels');
        if (saved) { customLevels = JSON.parse(saved); }
    }
    function deleteLevel(index) {
        if (confirm(`Are you sure you want to delete "${customLevels[index].name}"?`)) {
            customLevels.splice(index, 1);
            saveCustomLevels();
            populateLevelMenu();
        }
    }
    function exportLevel(index) {
        const level = customLevels[index];
        const blob = new Blob([level.data.trim()], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${level.name.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    initializeDomGrid();
    loadCustomLevels();
    populateLevelMenu();
    resetGame();
    render();
});
</script>
</body>
</html>
